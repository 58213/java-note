spring:
  shardingsphere:
    datasource:
      names:
        - sharding0
        - sharding1
      ds0:
        type: com.alibaba.druid.pool.DruidDataSource
        driver-class: com.mysql.jdbc.Driver
        jdbc-url: jdbc:mysql://localhost:3306/sharding0
        username: root
        password: root2020!
      ds1:
        type: com.alibaba.druid.pool.DruidDataSource
        driver-class: com.mysql.jdbc.Driver
        jdbc-url: jdbc:mysql://localhost:3306/sharding1
        username: root
        password: root2020!
    sharding:
      # 默认分库策略
      default-database-strategy:
        # 行表达式
        inline:
          # 分库字段
          sharding-column: id
          # 分库规则
          algorithm-expression: sharding$->{id % 2}
      # 分表策略
      tables:
        sys_log:
          # 真实的数据节点，数据源+表名的形式
#          actual-data-nodes: sharding$->{0..1}.data$->{0..1}
          table-strategy:
            standard:
              sharding-column: create_time
              precise-algorithm-class-name:
              range-algorithm-className:
          # 自增列生成规则，这里用雪花算法
          key-generator:
            colum: id
            type: SNOWFLAKE
            props:
              worker:
                id: 33
      # 配置绑定表，连表查询时减少路由查询次数。（相同分表字段和规则的表）
#      binding-tables:
#        - user
#        - order
      # 配置广播表：所有分片数据源中都存在的表，表结构和数据都一样。适用于数据量不大，但是需要和海量数据进行联查，如字典表
#      broadcast-tables: dict
    # 显示SQL
    props:
      sql:
        show: true
mybatis:
  type-aliases-package: org.ylc.note.shardingsphere.entity
  mapper-locations: classpath*:/mapper/**/*.xml
  configuration:
    # 开启驼峰类型的命名规则
    map-underscore-to-camel-case: true